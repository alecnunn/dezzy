"""Generated by dezzy Python backend"""
from dataclasses import dataclass
from enum import IntEnum
from typing import List
import struct

class ColorType(IntEnum):
    GRAYSCALE = 0
    RGB = 2
    PALETTE = 3
    GRAYSCALE_ALPHA = 4
    RGBA = 6


class CompressionMethod(IntEnum):
    DEFLATE = 0


class FilterMethod(IntEnum):
    ADAPTIVE = 0


class InterlaceMethod(IntEnum):
    NONE = 0
    ADAM7 = 1


@dataclass
class IHDRChunk:
    width: int  # Image width in pixels
    height: int  # Image height in pixels
    bit_depth: int  # Bits per sample (1, 2, 4, 8, or 16)
    color_type: ColorType  # Color type of the image
    compression_method: CompressionMethod  # Compression method (always 0 for DEFLATE)
    filter_method: FilterMethod  # Filter method (always 0 for adaptive filtering)
    interlace_method: InterlaceMethod  # Interlace method (0 for none, 1 for Adam7)

    @staticmethod
    def read(buffer: bytes, offset: int = 0) -> tuple['IHDRChunk', int]:
        """Read IHDRChunk from bytes. Returns (instance, bytes_read)"""
        pos = offset
        width = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        height = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        bit_depth = struct.unpack_from('B', buffer, pos)[0]
        pos += 1
        color_type = struct.unpack_from('B', buffer, pos)[0]
        pos += 1
        compression_method = struct.unpack_from('B', buffer, pos)[0]
        pos += 1
        filter_method = struct.unpack_from('B', buffer, pos)[0]
        pos += 1
        interlace_method = struct.unpack_from('B', buffer, pos)[0]
        pos += 1
        return IHDRChunk(width, height, bit_depth, color_type, compression_method, filter_method, interlace_method), pos - offset

    def write(self) -> bytes:
        """Write IHDRChunk to bytes"""
        result = bytearray()
        result.extend(struct.pack('>I', self.width))
        result.extend(struct.pack('>I', self.height))
        result.extend(struct.pack('>B', self.bit_depth))
        result.extend(struct.pack('>B', self.color_type))
        result.extend(struct.pack('>B', self.compression_method))
        result.extend(struct.pack('>B', self.filter_method))
        result.extend(struct.pack('>B', self.interlace_method))
        return bytes(result)


@dataclass
class Chunk:
    length: int  # Length of the data field
    chunk_type: List[int]  # 4-byte chunk type identifier
    data: List[int]  # Variable-length chunk data
    crc: int  # CRC32 checksum

    @staticmethod
    def read(buffer: bytes, offset: int = 0) -> tuple['Chunk', int]:
        """Read Chunk from bytes. Returns (instance, bytes_read)"""
        pos = offset
        length = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        chunk_type = []
        for _ in range(4):
            val = struct.unpack_from('B', buffer, pos)[0]
            pos += 1
            chunk_type.append(val)
        data = []
        for _ in range(length):
            val = struct.unpack_from('B', buffer, pos)[0]
            pos += 1
            data.append(val)
        crc = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        return Chunk(length, chunk_type, data, crc), pos - offset

    def write(self) -> bytes:
        """Write Chunk to bytes"""
        result = bytearray()
        result.extend(struct.pack('>I', self.length))
        for item in self.chunk_type:
            result.extend(struct.pack('>B', item))
        for item in self.data:
            result.extend(struct.pack('>B', item))
        result.extend(struct.pack('>I', self.crc))
        return bytes(result)


@dataclass
class PNGWithIHDR:
    signature: List[int]  # PNG signature: 89 50 4E 47 0D 0A 1A 0A
    ihdr_length: int  # IHDR chunk length (should be 13)
    ihdr_type: List[int]  # IHDR chunk type identifier
    ihdr: IHDRChunk  # Parsed IHDR chunk data
    ihdr_crc: int  # IHDR CRC32 checksum
    remaining_chunks: List[Chunk]  # Remaining chunks until EOF

    @staticmethod
    def read(buffer: bytes, offset: int = 0) -> tuple['PNGWithIHDR', int]:
        """Read PNGWithIHDR from bytes. Returns (instance, bytes_read)"""
        pos = offset
        signature = []
        for _ in range(8):
            val = struct.unpack_from('B', buffer, pos)[0]
            pos += 1
            signature.append(val)
        ihdr_length = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        ihdr_type = []
        for _ in range(4):
            val = struct.unpack_from('B', buffer, pos)[0]
            pos += 1
            ihdr_type.append(val)
        ihdr, bytes_read = IHDRChunk.read(buffer, pos)
        pos += bytes_read
        ihdr_crc = struct.unpack_from('>I', buffer, pos)[0]
        pos += 4
        remaining_chunks = []
        while pos < len(buffer):
            val, bytes_read = Chunk.read(buffer, pos)
            pos += bytes_read
            remaining_chunks.append(val)
        return PNGWithIHDR(signature, ihdr_length, ihdr_type, ihdr, ihdr_crc, remaining_chunks), pos - offset

    def write(self) -> bytes:
        """Write PNGWithIHDR to bytes"""
        result = bytearray()
        for item in self.signature:
            result.extend(struct.pack('>B', item))
        result.extend(struct.pack('>I', self.ihdr_length))
        for item in self.ihdr_type:
            result.extend(struct.pack('>B', item))
        result.extend(self.ihdr.write())
        result.extend(struct.pack('>I', self.ihdr_crc))
        for item in self.remaining_chunks:
            result.extend(item.write())
        return bytes(result)


