use dezzy_core::hir::Endianness;
use dezzy_core::lir::{LirFormat, LirType};
use serde_json;
use std::alloc::{alloc as system_alloc, Layout};
use std::slice;

// Global allocator for string returns
static mut LAST_ALLOCATION: Vec<u8> = Vec::new();

/// Allocate memory in WASM linear memory
/// Returns pointer to allocated memory
#[no_mangle]
pub extern "C" fn alloc(size: i32) -> *mut u8 {
    let layout = Layout::from_size_align(size as usize, 1).unwrap();
    unsafe { system_alloc(layout) }
}

/// Get backend name
/// Returns (ptr, len) tuple
#[no_mangle]
pub extern "C" fn get_name() -> (i32, i32) {
    let name = b"python";
    unsafe {
        LAST_ALLOCATION = name.to_vec();
        (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32)
    }
}

/// Get backend version
/// Returns (ptr, len) tuple
#[no_mangle]
pub extern "C" fn get_version() -> (i32, i32) {
    let version = b"0.1.0";
    unsafe {
        LAST_ALLOCATION = version.to_vec();
        (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32)
    }
}

/// Get file extension for generated code
/// Returns (ptr, len) tuple
#[no_mangle]
pub extern "C" fn get_file_extension() -> (i32, i32) {
    let ext = b"py";
    unsafe {
        LAST_ALLOCATION = ext.to_vec();
        (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32)
    }
}

/// Generate Python code from LIR JSON
/// Returns (ptr, len) tuple
#[no_mangle]
pub extern "C" fn generate(lir_ptr: i32, lir_len: i32) -> (i32, i32) {
    // Read LIR JSON from memory
    let lir_json = unsafe {
        let bytes = slice::from_raw_parts(lir_ptr as *const u8, lir_len as usize);
        std::str::from_utf8_unchecked(bytes)
    };

    // Parse LIR
    let lir: LirFormat = match serde_json::from_str(lir_json) {
        Ok(lir) => lir,
        Err(e) => {
            let error_msg = format!("Failed to parse LIR: {}", e);
            unsafe {
                LAST_ALLOCATION = error_msg.into_bytes();
                return (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32);
            }
        }
    };

    // Generate Python code
    let code = match generate_python(&lir) {
        Ok(code) => code,
        Err(e) => {
            let error_msg = format!("Code generation failed: {}", e);
            unsafe {
                LAST_ALLOCATION = error_msg.into_bytes();
                return (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32);
            }
        }
    };

    // Store result and return pointer
    unsafe {
        LAST_ALLOCATION = code.into_bytes();
        (LAST_ALLOCATION.as_ptr() as i32, LAST_ALLOCATION.len() as i32)
    }
}

fn generate_python(lir: &LirFormat) -> Result<String, String> {
    let mut code = String::new();

    // Header
    code.push_str("\"\"\"Generated by dezzy Python backend\"\"\"\n");
    code.push_str("from dataclasses import dataclass\n");
    code.push_str("from typing import List\n");
    code.push_str("import struct\n\n");

    // Generate classes for each type
    for lir_type in &lir.types {
        code.push_str(&generate_type(lir_type, lir.endianness)?);
        code.push_str("\n\n");
    }

    Ok(code)
}

fn generate_type(lir_type: &LirType, endianness: Endianness) -> Result<String, String> {
    let mut code = String::new();

    // Generate dataclass
    code.push_str(&format!("@dataclass\n"));
    code.push_str(&format!("class {}:\n", lir_type.name));

    // Fields
    for field in &lir_type.fields {
        let py_type = lir_type_to_python(&field.type_info);
        if let Some(doc) = &field.doc {
            code.push_str(&format!("    {}: {}  # {}\n", field.name, py_type, doc));
        } else {
            code.push_str(&format!("    {}: {}\n", field.name, py_type));
        }
    }

    code.push_str("\n");

    // read() method
    code.push_str(&format!("    @staticmethod\n"));
    code.push_str(&format!("    def read(data: bytes, offset: int = 0) -> tuple['{}', int]:\n", lir_type.name));
    code.push_str(&format!("        \"\"\"Read {} from bytes. Returns (instance, bytes_read)\"\"\"\n", lir_type.name));
    code.push_str(&format!("        pos = offset\n"));

    // Generate read logic based on operations
    code.push_str(&generate_read_impl(lir_type, endianness)?);

    code.push_str(&format!("        return {}, pos - offset\n", lir_type.name));

    code.push_str("\n");

    // write() method
    code.push_str(&format!("    def write(self) -> bytes:\n"));
    code.push_str(&format!("        \"\"\"Write {} to bytes\"\"\"\n", lir_type.name));
    code.push_str(&format!("        result = bytearray()\n"));

    code.push_str(&generate_write_impl(lir_type, endianness)?);

    code.push_str(&format!("        return bytes(result)\n"));

    Ok(code)
}

fn lir_type_to_python(type_str: &str) -> String {
    // Check for arrays
    if let Some(bracket_pos) = type_str.find('[') {
        if !type_str.ends_with(']') {
            return type_str.to_string();
        }
        let element_type = &type_str[..bracket_pos];
        let py_element = lir_type_to_python(element_type);
        return format!("List[{}]", py_element);
    }

    match type_str {
        "u8" | "i8" => "int".to_string(),
        "u16" | "i16" => "int".to_string(),
        "u32" | "i32" => "int".to_string(),
        "u64" | "i64" => "int".to_string(),
        other => other.to_string(), // User-defined type
    }
}

fn generate_read_impl(lir_type: &LirType, endianness: Endianness) -> Result<String, String> {
    let mut code = String::new();
    let endian_char = match endianness {
        Endianness::Little => '<',
        Endianness::Big => '>',
        Endianness::Native => '=',
    };

    // Collect field values
    for field in &lir_type.fields {
        let field_name = &field.name;
        let type_info = &field.type_info;

        // Parse type to generate read code
        if let Some(bracket_pos) = type_info.find('[') {
            // Array type
            let element_type = &type_info[..bracket_pos];
            let size_str = &type_info[bracket_pos + 1..type_info.len() - 1];

            if let Ok(size) = size_str.parse::<usize>() {
                // Fixed-size array
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", size));
                let read_elem = generate_read_element(element_type, endian_char);
                code.push_str(&format!("            val = {}\n", read_elem));
                code.push_str(&format!("            pos += struct.calcsize('{}{}')\n", endian_char, type_to_format(element_type)));
                code.push_str(&format!("            {}.append(val)\n", field_name));
            } else {
                // Dynamic array
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", size_str));
                let read_elem = generate_read_element(element_type, endian_char);
                code.push_str(&format!("            val = {}\n", read_elem));
                code.push_str(&format!("            pos += struct.calcsize('{}{}')\n", endian_char, type_to_format(element_type)));
                code.push_str(&format!("            {}.append(val)\n", field_name));
            }
        } else if is_primitive(type_info) {
            // Primitive type
            let fmt = type_to_format(type_info);
            code.push_str(&format!("        {} = struct.unpack_from('{}{}', data, pos)[0]\n", field_name, endian_char, fmt));
            code.push_str(&format!("        pos += struct.calcsize('{}{}')\n", endian_char, fmt));
        } else {
            // User-defined type
            code.push_str(&format!("        {}, bytes_read = {}.read(data, pos)\n", field_name, type_info));
            code.push_str(&format!("        pos += bytes_read\n"));
        }
    }

    Ok(code)
}

fn generate_write_impl(lir_type: &LirType, endianness: Endianness) -> Result<String, String> {
    let mut code = String::new();
    let endian_char = match endianness {
        Endianness::Little => '<',
        Endianness::Big => '>',
        Endianness::Native => '=',
    };

    for field in &lir_type.fields {
        let field_name = &field.name;
        let type_info = &field.type_info;

        if let Some(bracket_pos) = type_info.find('[') {
            // Array type
            let element_type = &type_info[..bracket_pos];
            code.push_str(&format!("        for item in self.{}:\n", field_name));
            if is_primitive(element_type) {
                let fmt = type_to_format(element_type);
                code.push_str(&format!("            result.extend(struct.pack('{}{}', item))\n", endian_char, fmt));
            } else {
                code.push_str(&format!("            result.extend(item.write())\n"));
            }
        } else if is_primitive(type_info) {
            let fmt = type_to_format(type_info);
            code.push_str(&format!("        result.extend(struct.pack('{}{}', self.{}))\n", endian_char, fmt, field_name));
        } else {
            code.push_str(&format!("        result.extend(self.{}.write())\n", field_name));
        }
    }

    Ok(code)
}

fn generate_read_element(element_type: &str, endian_char: char) -> String {
    if is_primitive(element_type) {
        let fmt = type_to_format(element_type);
        format!("struct.unpack_from('{}{}', data, pos)[0]", endian_char, fmt)
    } else {
        format!("{}.read(data, pos)[0]", element_type)
    }
}

fn is_primitive(type_str: &str) -> bool {
    matches!(type_str, "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64")
}

fn type_to_format(type_str: &str) -> &'static str {
    match type_str {
        "u8" => "B",
        "i8" => "b",
        "u16" => "H",
        "i16" => "h",
        "u32" => "I",
        "i32" => "i",
        "u64" => "Q",
        "i64" => "q",
        _ => "B", // Default
    }
}
