#![warn(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]
#![allow(clippy::too_many_lines)]

mod expr_codegen;

use dezzy_core::hir::{Endianness, HirAssertion, HirAssertValue, HirEnum, HirPrimitiveType};
use dezzy_core::lir::{LirField, LirFormat, LirType, VarId};
use expr_codegen::generate_expr;
use serde_json;
use std::alloc::{alloc as system_alloc, Layout};
use std::collections::HashMap;
use std::slice;
use std::sync::Mutex;

// Global allocator for string returns - using Mutex for safe mutation
static LAST_ALLOCATION: Mutex<Vec<u8>> = Mutex::new(Vec::new());

// Constants for pointer/length packing in i64
const PTR_LEN_SHIFT_BITS: i32 = 32;
const PTR_MASK: i64 = 0xFFFF_FFFF;

// Memory allocation alignment (byte-aligned)
const WASM_ALLOC_ALIGNMENT: usize = 1;

/// Allocate memory in WASM linear memory
/// Returns pointer to allocated memory
#[no_mangle]
pub extern "C" fn alloc(size: i32) -> *mut u8 {
    let layout = Layout::from_size_align(size as usize, WASM_ALLOC_ALIGNMENT)
        .expect("layout with byte alignment should always succeed");
    unsafe { system_alloc(layout) }
}

/// Get backend name
/// Returns packed (ptr, len) as i64: high 32 bits = len, low 32 bits = ptr
#[no_mangle]
pub extern "C" fn get_name() -> i64 {
    let name = b"python";
    let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
    *alloc = name.to_vec();
    pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32)
}

/// Get backend version
/// Returns packed (ptr, len) as i64
#[no_mangle]
pub extern "C" fn get_version() -> i64 {
    let version = b"0.1.0";
    let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
    *alloc = version.to_vec();
    pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32)
}

/// Get file extension for generated code
/// Returns packed (ptr, len) as i64
#[no_mangle]
pub extern "C" fn get_file_extension() -> i64 {
    let ext = b"py";
    let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
    *alloc = ext.to_vec();
    pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32)
}

/// Pack pointer and length into a single i64
/// Low 32 bits: pointer, High 32 bits: length
fn pack_ptr_len(ptr: i32, len: i32) -> i64 {
    ((len as i64) << PTR_LEN_SHIFT_BITS) | (ptr as i64 & PTR_MASK)
}

/// Generate Python code from LIR JSON
/// Returns packed (ptr, len) as i64
#[no_mangle]
pub extern "C" fn generate(lir_ptr: i32, lir_len: i32) -> i64 {
    // Read LIR JSON from memory
    let lir_json = unsafe {
        let bytes = slice::from_raw_parts(lir_ptr as *const u8, lir_len as usize);
        std::str::from_utf8_unchecked(bytes)
    };

    // Parse LIR
    let lir: LirFormat = match serde_json::from_str(lir_json) {
        Ok(lir) => lir,
        Err(e) => {
            let error_msg = format!("Failed to parse LIR: {}", e);
            let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
            *alloc = error_msg.into_bytes();
            return pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32);
        }
    };

    // Generate Python code
    let code = match generate_python(&lir) {
        Ok(code) => code,
        Err(e) => {
            let error_msg = format!("Code generation failed: {}", e);
            let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
            *alloc = error_msg.into_bytes();
            return pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32);
        }
    };

    // Store result and return pointer
    let mut alloc = LAST_ALLOCATION.lock().expect("mutex should not be poisoned");
    *alloc = code.into_bytes();
    pack_ptr_len(alloc.as_ptr() as i32, alloc.len() as i32)
}

fn generate_enum(enum_def: &HirEnum) -> String {
    let mut code = String::new();

    code.push_str(&format!("class {}(IntEnum):\n", enum_def.name));

    for value in &enum_def.values {
        code.push_str(&format!("    {} = {}\n", value.name, value.value));
    }

    code
}

fn generate_python(lir: &LirFormat) -> Result<String, String> {
    let mut code = String::new();

    // Header
    code.push_str("\"\"\"Generated by dezzy Python backend\"\"\"\n");
    code.push_str("from dataclasses import dataclass\n");
    code.push_str("from enum import IntEnum\n");
    code.push_str("from typing import List, Optional\n");
    code.push_str("import struct\n\n");

    // Generate enums first
    for enum_def in &lir.enums {
        code.push_str(&generate_enum(enum_def));
        code.push_str("\n\n");
    }

    // Generate classes for each type
    for lir_type in &lir.types {
        code.push_str(&generate_type(lir_type, lir.endianness, &lir.enums)?);
        code.push_str("\n\n");
    }

    Ok(code)
}

fn generate_type(lir_type: &LirType, endianness: Endianness, enums: &[HirEnum]) -> Result<String, String> {
    let mut code = String::new();

    // Generate dataclass
    code.push_str(&format!("@dataclass\n"));
    code.push_str(&format!("class {}:\n", lir_type.name));

    // Fields (exclude skip fields)
    for field in &lir_type.fields {
        if field.skip.is_some() {
            continue;  // Skip fields are not part of the struct
        }
        let mut py_type = lir_type_to_python(&field.type_info);
        // Wrap conditional fields in Optional
        if field.is_optional {
            py_type = format!("Optional[{}] = None", py_type);
        }
        if let Some(doc) = &field.doc {
            code.push_str(&format!("    {}: {}  # {}\n", field.name, py_type, doc));
        } else {
            code.push_str(&format!("    {}: {}\n", field.name, py_type));
        }
    }

    code.push_str("\n");

    // read() method
    code.push_str(&format!("    @staticmethod\n"));
    code.push_str(&format!("    def read(buffer: bytes, offset: int = 0) -> tuple['{}', int]:\n", lir_type.name));
    code.push_str(&format!("        \"\"\"Read {} from bytes. Returns (instance, bytes_read)\"\"\"\n", lir_type.name));
    code.push_str(&format!("        pos = offset\n"));

    // Build var_id to field name mapping
    let mut var_to_field = std::collections::HashMap::new();
    for field in &lir_type.fields {
        var_to_field.insert(field.var_id, field.name.clone());
    }

    // Generate read logic based on operations
    code.push_str(&generate_read_from_operations(&lir_type.operations, &var_to_field, &lir_type.fields, endianness)?);

    // Create instance with collected fields (exclude skip fields)
    let field_names: Vec<_> = lir_type.fields.iter()
        .filter(|f| f.skip.is_none())
        .map(|f| f.name.as_str())
        .collect();
    code.push_str(&format!("        return {}({}), pos - offset\n", lir_type.name, field_names.join(", ")));

    code.push_str("\n");

    // write() method
    code.push_str(&format!("    def write(self) -> bytes:\n"));
    code.push_str(&format!("        \"\"\"Write {} to bytes\"\"\"\n", lir_type.name));
    code.push_str(&format!("        result = bytearray()\n"));

    // Check if we need BitWriter
    let has_write_bits = lir_type.operations.iter().any(|op| matches!(op, LirOperation::WriteBits { .. }));
    if has_write_bits {
        code.push_str("        # BitWriter state (initialized on first use)\n");
        code.push_str("        if not hasattr(self.write, '_bit_buffer'):\n");
        code.push_str("            self.write._bit_buffer = 0\n");
        code.push_str("            self.write._bits_used = 0\n");
        code.push_str("        \n");
    }

    code.push_str(&generate_write_from_operations(lir_type, endianness, enums)?);

    // Flush any remaining bits from BitWriter
    if has_write_bits {
        code.push_str("        \n");
        code.push_str("        # Flush any remaining bits in BitWriter\n");
        code.push_str("        if self.write._bits_used > 0:\n");
        code.push_str("            self.write._bit_buffer <<= (8 - self.write._bits_used)\n");
        code.push_str("            result.extend(struct.pack('B', self.write._bit_buffer))\n");
        code.push_str("            self.write._bit_buffer = 0\n");
        code.push_str("            self.write._bits_used = 0\n");
        code.push_str("        \n");
    }

    code.push_str(&format!("        return bytes(result)\n"));

    Ok(code)
}

fn lir_type_to_python(type_str: &str) -> String {
    // Handle string types
    if type_str == "cstr" || type_str.starts_with("str(") {
        return "str".to_string();
    }

    // Handle blob type
    if type_str.starts_with("blob(") {
        return "bytes".to_string();
    }

    // Check for arrays
    if let Some(bracket_pos) = type_str.find('[') {
        if !type_str.ends_with(']') {
            return type_str.to_string();
        }
        let element_type = &type_str[..bracket_pos];

        // Special case: str[N] is a fixed-length string
        if element_type == "str" {
            return "str".to_string();
        }

        let py_element = lir_type_to_python(element_type);
        return format!("List[{}]", py_element);
    }

    match type_str {
        "u8" | "i8" => "int".to_string(),
        "u16" | "i16" => "int".to_string(),
        "u32" | "i32" => "int".to_string(),
        "u64" | "i64" => "int".to_string(),
        // Bitfield types
        "u1" | "u2" | "u3" | "u4" | "u5" | "u6" | "u7" => "int".to_string(),
        "i1" | "i2" | "i3" | "i4" | "i5" | "i6" | "i7" => "int".to_string(),
        other => other.to_string(), // User-defined type
    }
}

use dezzy_core::lir::LirOperation;

fn generate_assertion_check(field_name: &str, assertion: &HirAssertion) -> String {
    let mut code = String::new();

    match assertion {
        HirAssertion::Equals(assert_val) => {
            match assert_val {
                HirAssertValue::Int(value) => {
                    code.push_str(&format!("        if {} != {}:\n", field_name, value));
                    code.push_str(&format!("            raise ValueError(\"Field '{}' must equal {}, got {{}}\".format({}))\n", field_name, value, field_name));
                }
                HirAssertValue::IntArray(values) => {
                    code.push_str(&format!("        expected = [{}]\n", values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(", ")));
                    code.push_str(&format!("        if list({}) != expected:\n", field_name));
                    code.push_str(&format!("            raise ValueError(\"Field '{}' does not match expected value\")\n", field_name));
                }
            }
        }
        HirAssertion::NotEquals(assert_val) => {
            match assert_val {
                HirAssertValue::Int(value) => {
                    code.push_str(&format!("        if {} == {}:\n", field_name, value));
                    code.push_str(&format!("            raise ValueError(\"Field '{}' must not equal {}\")\n", field_name, value));
                }
                HirAssertValue::IntArray(_) => {
                    code.push_str(&format!("        # NotEquals array assertion not implemented for field '{}'\n", field_name));
                }
            }
        }
        HirAssertion::GreaterThan(threshold) => {
            code.push_str(&format!("        if {} <= {}:\n", field_name, threshold));
            code.push_str(&format!("            raise ValueError(\"Field '{}' must be greater than {}, got {{}}\".format({}))\n", field_name, threshold, field_name));
        }
        HirAssertion::GreaterOrEqual(threshold) => {
            code.push_str(&format!("        if {} < {}:\n", field_name, threshold));
            code.push_str(&format!("            raise ValueError(\"Field '{}' must be >= {}, got {{}}\".format({}))\n", field_name, threshold, field_name));
        }
        HirAssertion::LessThan(threshold) => {
            code.push_str(&format!("        if {} >= {}:\n", field_name, threshold));
            code.push_str(&format!("            raise ValueError(\"Field '{}' must be less than {}, got {{}}\".format({}))\n", field_name, threshold, field_name));
        }
        HirAssertion::LessOrEqual(threshold) => {
            code.push_str(&format!("        if {} > {}:\n", field_name, threshold));
            code.push_str(&format!("            raise ValueError(\"Field '{}' must be <= {}, got {{}}\".format({}))\n", field_name, threshold, field_name));
        }
        HirAssertion::In(values) => {
            code.push_str(&format!("        allowed = [{}]\n", values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(", ")));
            code.push_str(&format!("        if {} not in allowed:\n", field_name));
            code.push_str(&format!("            raise ValueError(\"Field '{}' has invalid value {{}}\".format({}))\n", field_name, field_name));
        }
        HirAssertion::NotIn(values) => {
            code.push_str(&format!("        forbidden = [{}]\n", values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(", ")));
            code.push_str(&format!("        if {} in forbidden:\n", field_name));
            code.push_str(&format!("            raise ValueError(\"Field '{}' has forbidden value {{}}\".format({}))\n", field_name, field_name));
        }
        HirAssertion::Range { min, max } => {
            code.push_str(&format!("        if {} < {} or {} > {}:\n", field_name, min, field_name, max));
            code.push_str(&format!("            raise ValueError(\"Field '{}' must be in range [{}, {}], got {{}}\".format({}))\n", field_name, min, max, field_name));
        }
    }

    code
}

fn generate_read_from_operations(
    operations: &[LirOperation],
    var_to_field: &HashMap<VarId, String>,
    fields: &[LirField],
    endianness: Endianness,
) -> Result<String, String> {
    let mut code = String::new();

    for op in operations {
        // Stop processing when we hit CreateStruct (marks end of read operations)
        if matches!(op, LirOperation::CreateStruct { .. }) {
            break;
        }

        match op {
            LirOperation::ReadU8 { dest } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = struct.unpack_from('B', buffer, pos)[0]\n", field_name));
                code.push_str("        pos += 1\n");
                // Add assertion if field has one
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadU16 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}H', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 2\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadU32 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}I', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 4\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadU64 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}Q', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 8\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadI8 { dest } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = struct.unpack_from('b', buffer, pos)[0]\n", field_name));
                code.push_str("        pos += 1\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadI16 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}h', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 2\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadI32 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}i', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 4\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadI64 { dest, .. } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let endian_char = endian_to_char(endianness);
                code.push_str(&format!("        {} = struct.unpack_from('{}q', buffer, pos)[0]\n", field_name, endian_char));
                code.push_str("        pos += 8\n");
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadArray { dest, element_op, count } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", count));
                code.push_str(&generate_array_element_read_multiline(element_op, field_name, endianness, 3)?);
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadDynamicArray { dest, element_op, size_var } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let size_field = var_to_field.get(size_var).ok_or("Unknown size var_id")?;
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", size_field));
                code.push_str(&generate_array_element_read_multiline(element_op, field_name, endianness, 3)?);
            }
            LirOperation::ReadUntilEofArray { dest, element_op } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str("        while pos < len(buffer):\n");
                code.push_str(&generate_array_element_read_multiline(element_op, field_name, endianness, 3)?);
            }
            LirOperation::ReadUntilConditionArray { dest, element_op, condition } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str("        while True:\n");
                code.push_str(&generate_array_element_read_multiline(element_op, field_name, endianness, 3)?);
                let condition_code = generate_expr(condition, field_name)?;
                code.push_str(&format!("            if {}:\n", condition_code));
                code.push_str("                break\n");
            }
            LirOperation::ReadStruct { dest, type_name } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {}, bytes_read = {}.read(buffer, pos)\n", field_name, type_name));
                code.push_str("        pos += bytes_read\n");
            }
            LirOperation::ReadFixedString { dest, length } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str(&format!("        {} = buffer[pos:pos + {}].decode('utf-8', errors='replace')\n", field_name, length));
                code.push_str(&format!("        pos += {}\n", length));
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadNullTerminatedString { dest } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str("        string_bytes = bytearray()\n");
                code.push_str("        while True:\n");
                code.push_str("            byte = struct.unpack_from('B', buffer, pos)[0]\n");
                code.push_str("            pos += 1\n");
                code.push_str("            if byte == 0:\n");
                code.push_str("                break\n");
                code.push_str("            string_bytes.append(byte)\n");
                code.push_str(&format!("        {} = string_bytes.decode('utf-8', errors='replace')\n", field_name));
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadLengthPrefixedString { dest, length_var } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let length_field = var_to_field.get(length_var).ok_or("Unknown length_var")?;
                code.push_str(&format!("        {} = buffer[pos:pos + {}].decode('utf-8', errors='replace')\n", field_name, length_field));
                code.push_str(&format!("        pos += {}\n", length_field));
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ReadBlob { dest, size_var } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                let size_field = var_to_field.get(size_var).ok_or("Unknown size_var")?;
                code.push_str(&format!("        {} = buffer[pos:pos + {}]\n", field_name, size_field));
                code.push_str(&format!("        pos += {}\n", size_field));
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::Skip { size_var } => {
                let size_field = var_to_field.get(size_var).ok_or("Unknown size_var")?;
                code.push_str(&format!("        pos += {}  # skip\n", size_field));
            }
            LirOperation::PadFixed { bytes } => {
                code.push_str(&format!("        pos += {}  # fixed padding\n", bytes));
            }
            LirOperation::Align { boundary } => {
                code.push_str(&format!("        # Align to {}-byte boundary\n", boundary));
                code.push_str(&format!("        padding = ({} - (pos % {})) % {}\n", boundary, boundary, boundary));
                code.push_str("        pos += padding\n");
            }
            LirOperation::ReadBits { dest, num_bits, signed } => {
                let field_name = var_to_field.get(dest).ok_or("Unknown var_id")?;
                code.push_str("        # BitReader state (initialized on first use)\n");
                code.push_str("        if not hasattr(read, '_bit_buffer'):\n");
                code.push_str("            read._bit_buffer = 0\n");
                code.push_str("            read._bits_available = 0\n");
                code.push_str("        \n");
                code.push_str(&format!("        # Read {} bits (MSB first)\n", num_bits));
                code.push_str(&format!("        {} = 0\n", field_name));
                code.push_str(&format!("        bits_needed = {}\n", num_bits));
                code.push_str("        while bits_needed > 0:\n");
                code.push_str("            if read._bits_available == 0:\n");
                code.push_str("                read._bit_buffer = struct.unpack_from('B', buffer, pos)[0]\n");
                code.push_str("                pos += 1\n");
                code.push_str("                read._bits_available = 8\n");
                code.push_str(&format!("            bits_to_read = min(bits_needed, read._bits_available)\n"));
                code.push_str(&format!("            {} = ({} << bits_to_read) | ((read._bit_buffer >> (read._bits_available - bits_to_read)) & ((1 << bits_to_read) - 1))\n", field_name, field_name));
                code.push_str("            read._bits_available -= bits_to_read\n");
                code.push_str("            bits_needed -= bits_to_read\n");
                if *signed {
                    code.push_str(&format!("        # Sign extend if high bit is set\n"));
                    code.push_str(&format!("        if {} & (1 << ({} - 1)):\n", field_name, num_bits));
                    code.push_str(&format!("            {} |= ~((1 << {}) - 1)\n", field_name, num_bits));
                }
                if let Some(field) = fields.iter().find(|f| f.var_id == *dest) {
                    if let Some(ref assertion) = field.assertion {
                        code.push_str(&generate_assertion_check(field_name, assertion));
                    }
                }
            }
            LirOperation::ConditionalBlock { condition, true_ops } => {
                use crate::expr_codegen::generate_expr;

                // Generate condition expression
                let condition_code = generate_expr(condition, "")?;
                code.push_str(&format!("        if {}:\n", condition_code));

                // Generate code for operations within the conditional block
                let inner_code = generate_read_from_operations(true_ops, var_to_field, fields, endianness)?;
                // Indent the inner code by one more level
                for line in inner_code.lines() {
                    if !line.is_empty() {
                        code.push_str("    ");
                        code.push_str(line);
                        code.push('\n');
                    }
                }
            }
            LirOperation::CreateStruct { .. } | LirOperation::AccessField { .. } => {
                // These operations are handled implicitly in Python
                // CreateStruct: we just return the collected fields
                // AccessField: fields are directly accessible as self.field_name
            }
            _ => {
                return Err(format!("Unsupported read operation: {:?}", op));
            }
        }
    }

    Ok(code)
}

fn generate_array_element_read_multiline(
    element_op: &LirOperation,
    array_name: &str,
    endianness: Endianness,
    indent_level: usize,
) -> Result<String, String> {
    let indent = "    ".repeat(indent_level);
    let mut code = String::new();

    match element_op {
        LirOperation::ReadU8 { .. } => {
            code.push_str(&format!("{}val = struct.unpack_from('B', buffer, pos)[0]\n", indent));
            code.push_str(&format!("{}pos += 1\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadU16 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}H', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 2\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadU32 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}I', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 4\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadU64 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}Q', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 8\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadI8 { .. } => {
            code.push_str(&format!("{}val = struct.unpack_from('b', buffer, pos)[0]\n", indent));
            code.push_str(&format!("{}pos += 1\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadI16 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}h', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 2\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadI32 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}i', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 4\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadI64 { .. } => {
            let endian_char = endian_to_char(endianness);
            code.push_str(&format!("{}val = struct.unpack_from('{}q', buffer, pos)[0]\n", indent, endian_char));
            code.push_str(&format!("{}pos += 8\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        LirOperation::ReadStruct { type_name, .. } => {
            code.push_str(&format!("{}val, bytes_read = {}.read(buffer, pos)\n", indent, type_name));
            code.push_str(&format!("{}pos += bytes_read\n", indent));
            code.push_str(&format!("{}{}.append(val)\n", indent, array_name));
        }
        _ => return Err(format!("Unsupported array element operation: {:?}", element_op))
    }

    Ok(code)
}

fn endian_to_char(endianness: Endianness) -> char {
    match endianness {
        Endianness::Little => '<',
        Endianness::Big => '>',
        Endianness::Native => '=',
    }
}

fn generate_write_from_operations(
    lir_type: &LirType,
    endianness: Endianness,
    enums: &[HirEnum],
) -> Result<String, String> {
    let mut code = String::new();
    let endian_char = endian_to_char(endianness);

    // Build var_to_field map
    let mut var_to_field = std::collections::HashMap::new();
    let mut in_write_section = false;

    // Build enum map
    let mut enum_types = std::collections::HashMap::new();
    for enum_def in enums {
        enum_types.insert(enum_def.name.clone(), enum_def.underlying_type);
    }

    for op in &lir_type.operations {
        // AccessField marks the start of write operations
        if let LirOperation::AccessField { dest, field_index, .. } = op {
            in_write_section = true;
            if *field_index < lir_type.fields.len() {
                var_to_field.insert(*dest, lir_type.fields[*field_index].name.clone());
            }
            continue;
        }

        if !in_write_section {
            continue;
        }

        match op {
            LirOperation::WriteU8 { src } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('B', self.{}))\n", field_name));
            }
            LirOperation::WriteU16 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}H', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteU32 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}I', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteU64 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}Q', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteI8 { src } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('b', self.{}))\n", field_name));
            }
            LirOperation::WriteI16 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}h', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteI32 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}i', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteI64 { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(struct.pack('{}q', self.{}))\n", endian_char, field_name));
            }
            LirOperation::WriteBits { src, num_bits } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        # Write {} bits (MSB first)\n", num_bits));
                code.push_str(&format!("        value = self.{}\n", field_name));
                code.push_str(&format!("        bits_to_write = {}\n", num_bits));
                code.push_str("        while bits_to_write > 0:\n");
                code.push_str("            bits_this_round = min(bits_to_write, 8 - self.write._bits_used)\n");
                code.push_str("            bits = (value >> (bits_to_write - bits_this_round)) & ((1 << bits_this_round) - 1)\n");
                code.push_str("            self.write._bit_buffer = (self.write._bit_buffer << bits_this_round) | bits\n");
                code.push_str("            self.write._bits_used += bits_this_round\n");
                code.push_str("            bits_to_write -= bits_this_round\n");
                code.push_str("            \n");
                code.push_str("            if self.write._bits_used == 8:\n");
                code.push_str("                result.extend(struct.pack('B', self.write._bit_buffer))\n");
                code.push_str("                self.write._bit_buffer = 0\n");
                code.push_str("                self.write._bits_used = 0\n");
            }
            LirOperation::WritePadFixed { bytes } => {
                code.push_str(&format!("        result.extend(b'\\x00' * {})  # fixed padding\n", bytes));
            }
            LirOperation::WriteAlign { boundary } => {
                code.push_str(&format!("        # Align to {}-byte boundary\n", boundary));
                code.push_str(&format!("        padding = ({} - (len(result) % {})) % {}\n", boundary, boundary, boundary));
                code.push_str("        result.extend(b'\\x00' * padding)\n");
            }
            LirOperation::WriteBlob { src } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(self.{})\n", field_name));
            }
            LirOperation::WriteNullTerminatedString { src } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(self.{}.encode('utf-8'))\n", field_name));
                code.push_str("        result.extend(struct.pack('B', 0))  # null terminator\n");
            }
            LirOperation::WriteFixedString { src, length } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        encoded = self.{}.encode('utf-8')\n", field_name));
                code.push_str(&format!("        for i in range({}):\n", length));
                code.push_str("            result.extend(struct.pack('B', encoded[i] if i < len(encoded) else 0))\n");
            }
            LirOperation::WriteLengthPrefixedString { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(self.{}.encode('utf-8'))\n", field_name));
            }
            LirOperation::WriteStruct { src, .. } => {
                let field_name = var_to_field.get(src).ok_or("Unknown var_id")?;
                code.push_str(&format!("        result.extend(self.{}.write())\n", field_name));
            }
            LirOperation::ConditionalBlock { condition, true_ops } => {
                use crate::expr_codegen::generate_expr;

                // Generate condition expression (use "self" as context for write operations)
                let condition_code = generate_expr(condition, "self")?;
                code.push_str(&format!("        if {}:\n", condition_code));

                // Build local var_to_field map for operations in this block
                let mut local_var_to_field = var_to_field.clone();

                // Process operations within the conditional block
                for inner_op in true_ops {
                    // Handle AccessField to build local mapping
                    if let LirOperation::AccessField { dest, field_index, .. } = inner_op {
                        if *field_index < lir_type.fields.len() {
                            local_var_to_field.insert(*dest, lir_type.fields[*field_index].name.clone());
                        }
                        continue; // Don't generate code for AccessField itself
                    }

                    // Generate code for the write operation
                    match inner_op {
                        LirOperation::WriteU8 { src } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('B', self.{}))\n", field_name));
                        }
                        LirOperation::WriteU16 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}H', self.{}))\n", endian_char, field_name));
                        }
                        LirOperation::WriteU32 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}I', self.{}))\n", endian_char, field_name));
                        }
                        LirOperation::WriteU64 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}Q', self.{}))\n", endian_char, field_name));
                        }
                        LirOperation::WriteI8 { src } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('b', self.{}))\n", field_name));
                        }
                        LirOperation::WriteI16 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}h', self.{}))\n", endian_char, field_name));
                        }
                        LirOperation::WriteI32 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}i', self.{}))\n", endian_char, field_name));
                        }
                        LirOperation::WriteI64 { src, .. } => {
                            let field_name = local_var_to_field.get(src).ok_or("Unknown var_id")?;
                            code.push_str(&format!("            result.extend(struct.pack('{}q', self.{}))\n", endian_char, field_name));
                        }
                        _ => {
                            // Skip other operations for now
                        }
                    }
                }
            }
            _ => {
                // Other operations (like WriteArray) - we'll skip for now
            }
        }
    }

    Ok(code)
}

fn generate_read_impl(lir_type: &LirType, endianness: Endianness) -> Result<String, String> {
    let mut code = String::new();
    let endian_char = match endianness {
        Endianness::Little => '<',
        Endianness::Big => '>',
        Endianness::Native => '=',
    };

    // Collect field values
    for field in &lir_type.fields {
        let field_name = &field.name;
        let type_info = &field.type_info;

        // Parse type to generate read code
        if let Some(bracket_pos) = type_info.find('[') {
            // Array type
            let element_type = &type_info[..bracket_pos];
            let size_str = &type_info[bracket_pos + 1..type_info.len() - 1];

            if let Ok(size) = size_str.parse::<usize>() {
                // Fixed-size array
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", size));

                if is_primitive(element_type) {
                    // Primitive type - use struct.calcsize
                    let read_elem = generate_read_element(element_type, endian_char);
                    code.push_str(&format!("            val = {}\n", read_elem));
                    code.push_str(&format!("            pos += struct.calcsize('{}{}')\n", endian_char, type_to_format(element_type)));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                } else {
                    // User-defined type - use bytes_read from read() method
                    code.push_str(&format!("            val, bytes_read = {}.read(buffer, pos)\n", element_type));
                    code.push_str(&format!("            pos += bytes_read\n"));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                }
            } else if size_str.is_empty() {
                // Until-EOF array
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str("        while pos < len(buffer):\n");

                if is_primitive(element_type) {
                    // Primitive type - use struct.calcsize
                    let read_elem = generate_read_element(element_type, endian_char);
                    code.push_str(&format!("            val = {}\n", read_elem));
                    code.push_str(&format!("            pos += struct.calcsize('{}{}')\n", endian_char, type_to_format(element_type)));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                } else {
                    // User-defined type - use bytes_read from read() method
                    code.push_str(&format!("            val, bytes_read = {}.read(buffer, pos)\n", element_type));
                    code.push_str(&format!("            pos += bytes_read\n"));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                }
            } else {
                // Dynamic array (count-prefixed)
                code.push_str(&format!("        {} = []\n", field_name));
                code.push_str(&format!("        for _ in range({}):\n", size_str));

                if is_primitive(element_type) {
                    // Primitive type - use struct.calcsize
                    let read_elem = generate_read_element(element_type, endian_char);
                    code.push_str(&format!("            val = {}\n", read_elem));
                    code.push_str(&format!("            pos += struct.calcsize('{}{}')\n", endian_char, type_to_format(element_type)));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                } else {
                    // User-defined type - use bytes_read from read() method
                    code.push_str(&format!("            val, bytes_read = {}.read(buffer, pos)\n", element_type));
                    code.push_str(&format!("            pos += bytes_read\n"));
                    code.push_str(&format!("            {}.append(val)\n", field_name));
                }
            }
        } else if is_primitive(type_info) {
            // Primitive type
            let fmt = type_to_format(type_info);
            code.push_str(&format!("        {} = struct.unpack_from('{}{}', buffer, pos)[0]\n", field_name, endian_char, fmt));
            code.push_str(&format!("        pos += struct.calcsize('{}{}')\n", endian_char, fmt));
        } else {
            // User-defined type
            code.push_str(&format!("        {}, bytes_read = {}.read(buffer, pos)\n", field_name, type_info));
            code.push_str(&format!("        pos += bytes_read\n"));
        }
    }

    Ok(code)
}

fn generate_write_impl(lir_type: &LirType, endianness: Endianness, enums: &[HirEnum]) -> Result<String, String> {
    let mut code = String::new();
    let endian_char = match endianness {
        Endianness::Little => '<',
        Endianness::Big => '>',
        Endianness::Native => '=',
    };

    // Build a map of enum names to their underlying types
    let mut enum_types = std::collections::HashMap::new();
    for enum_def in enums {
        enum_types.insert(enum_def.name.clone(), enum_def.underlying_type);
    }

    for field in &lir_type.fields {
        if field.skip.is_some() {
            continue;  // Skip fields are not written
        }

        let field_name = &field.name;
        let type_info = &field.type_info;

        // Handle blob type
        if type_info.starts_with("blob(") {
            code.push_str(&format!("        result.extend(self.{})\n", field_name));
            continue;
        }

        // Handle string types
        if type_info == "cstr" {
            // Null-terminated string
            code.push_str(&format!("        result.extend(self.{}.encode('utf-8'))\n", field_name));
            code.push_str("        result.extend(struct.pack('B', 0))  # null terminator\n");
            continue;
        } else if type_info.starts_with("str(") {
            // Length-prefixed string
            code.push_str(&format!("        result.extend(self.{}.encode('utf-8'))\n", field_name));
            continue;
        }

        if let Some(bracket_pos) = type_info.find('[') {
            let element_type = &type_info[..bracket_pos];

            // Special case: str[N] is a fixed-length string
            if element_type == "str" {
                let size_str = &type_info[bracket_pos + 1..type_info.len() - 1];
                if let Ok(size) = size_str.parse::<usize>() {
                    code.push_str(&format!("        encoded = self.{}.encode('utf-8')\n", field_name));
                    code.push_str(&format!("        for i in range({}):\n", size));
                    code.push_str("            result.extend(struct.pack('B', encoded[i] if i < len(encoded) else 0))\n");
                    continue;
                }
            }

            // Array type
            code.push_str(&format!("        for item in self.{}:\n", field_name));
            if is_primitive(element_type) {
                let fmt = type_to_format(element_type);
                code.push_str(&format!("            result.extend(struct.pack('{}{}', item))\n", endian_char, fmt));
            } else if let Some(underlying_type) = enum_types.get(element_type) {
                // Enum type - pack as underlying primitive
                let fmt = primitive_type_to_format(*underlying_type);
                code.push_str(&format!("            result.extend(struct.pack('{}{}', item))\n", endian_char, fmt));
            } else {
                code.push_str(&format!("            result.extend(item.write())\n"));
            }
        } else if is_bitfield(type_info) {
            // Bitfield type - need bit packing
            let num_bits = bitfield_num_bits(type_info);
            code.push_str("        # BitWriter state (initialized on first use)\n");
            code.push_str("        if not hasattr(self.write, '_bit_buffer'):\n");
            code.push_str("            self.write._bit_buffer = 0\n");
            code.push_str("            self.write._bits_used = 0\n");
            code.push_str("        \n");
            code.push_str(&format!("        # Write {} bits (MSB first)\n", num_bits));
            code.push_str(&format!("        value = self.{}\n", field_name));
            code.push_str(&format!("        bits_to_write = {}\n", num_bits));
            code.push_str("        while bits_to_write > 0:\n");
            code.push_str("            bits_this_round = min(bits_to_write, 8 - self.write._bits_used)\n");
            code.push_str("            bits = (value >> (bits_to_write - bits_this_round)) & ((1 << bits_this_round) - 1)\n");
            code.push_str("            self.write._bit_buffer = (self.write._bit_buffer << bits_this_round) | bits\n");
            code.push_str("            self.write._bits_used += bits_this_round\n");
            code.push_str("            bits_to_write -= bits_this_round\n");
            code.push_str("            \n");
            code.push_str("            if self.write._bits_used == 8:\n");
            code.push_str("                result.extend(struct.pack('B', self.write._bit_buffer))\n");
            code.push_str("                self.write._bit_buffer = 0\n");
            code.push_str("                self.write._bits_used = 0\n");
        } else if is_primitive(type_info) {
            let fmt = type_to_format(type_info);
            code.push_str(&format!("        result.extend(struct.pack('{}{}', self.{}))\n", endian_char, fmt, field_name));
        } else if let Some(underlying_type) = enum_types.get(type_info) {
            // Enum type - pack as underlying primitive
            let fmt = primitive_type_to_format(*underlying_type);
            code.push_str(&format!("        result.extend(struct.pack('{}{}', self.{}))\n", endian_char, fmt, field_name));
        } else {
            code.push_str(&format!("        result.extend(self.{}.write())\n", field_name));
        }
    }

    Ok(code)
}

fn generate_read_element(element_type: &str, endian_char: char) -> String {
    if is_primitive(element_type) {
        let fmt = type_to_format(element_type);
        format!("struct.unpack_from('{}{}', buffer, pos)[0]", endian_char, fmt)
    } else {
        format!("{}.read(buffer, pos)[0]", element_type)
    }
}

fn is_primitive(type_str: &str) -> bool {
    matches!(type_str, "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64")
}

fn is_bitfield(type_str: &str) -> bool {
    matches!(type_str, "u1" | "u2" | "u3" | "u4" | "u5" | "u6" | "u7" |
                       "i1" | "i2" | "i3" | "i4" | "i5" | "i6" | "i7")
}

fn bitfield_num_bits(type_str: &str) -> u8 {
    match type_str {
        "u1" | "i1" => 1,
        "u2" | "i2" => 2,
        "u3" | "i3" => 3,
        "u4" | "i4" => 4,
        "u5" | "i5" => 5,
        "u6" | "i6" => 6,
        "u7" | "i7" => 7,
        _ => 0,
    }
}

fn type_to_format(type_str: &str) -> &'static str {
    match type_str {
        "u8" => "B",
        "i8" => "b",
        "u16" => "H",
        "i16" => "h",
        "u32" => "I",
        "i32" => "i",
        "u64" => "Q",
        "i64" => "q",
        _ => "B", // Default
    }
}

fn primitive_type_to_format(prim_type: HirPrimitiveType) -> &'static str {
    match prim_type {
        HirPrimitiveType::U8 => "B",
        HirPrimitiveType::I8 => "b",
        HirPrimitiveType::U16 => "H",
        HirPrimitiveType::I16 => "h",
        HirPrimitiveType::U32 => "I",
        HirPrimitiveType::I32 => "i",
        HirPrimitiveType::U64 => "Q",
        HirPrimitiveType::I64 => "q",
        // Bitfield types - map to byte types
        HirPrimitiveType::U1 | HirPrimitiveType::U2 | HirPrimitiveType::U3
        | HirPrimitiveType::U4 | HirPrimitiveType::U5 | HirPrimitiveType::U6
        | HirPrimitiveType::U7 => "B",
        HirPrimitiveType::I1 | HirPrimitiveType::I2 | HirPrimitiveType::I3
        | HirPrimitiveType::I4 | HirPrimitiveType::I5 | HirPrimitiveType::I6
        | HirPrimitiveType::I7 => "b",
    }
}
